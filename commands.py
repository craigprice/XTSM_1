# -*- coding: utf-8 -*-
"""
Python twisted server, implements an HTTP socket-server and command queue to
execute python commands, parse XTSM, and manage data in user-specific contexts.  

Created on Thu May 16 18:24:40 2013
           
This software is described at
https://amo.phys.psu.edu/GemelkeLabWiki/index.php/Python_server

TODO:
    permit standard command library calls with POST payloads on websocket
    connections (for faster exchanges on standard calls) ?
    is this done and working ?
    redirect stdio to console
    execute command queue items on schedule
    queue in databomb upkeep (links and storage)
    
@author: Nate, Jed
"""


import uuid
import time
import sys
from datetime import datetime
from datetime import date   
import pdb
import colorama
colorama.init(strip=False)

import msgpack
import msgpack_numpy
from StringIO import StringIO


import simplejson
import XTSMobjectify
import DataBomb
import InfiniteFileStream
msgpack_numpy.patch()#This patch actually changes the behavior of "msgpack"
#specifically, it changes how, "encoding='utf-8'" functions when unpacking
import XTSM_Server_Objects
import XTSM_Transforms
import live_content
import file_locations
import glab_instrument

import matplotlib as mpl
import matplotlib.pyplot as plt 

import numpy

import collections
import sync
from scipy.optimize import curve_fit
DEBUG = True
      
NUM_RETAINED_XTSM=10


port = 8083
wsport = 8084
udpbport = 8085

        

        
class CommandQueue():
    """
    The CommandQueue manages server command executions; it is basically a stack
    of requests generated by incoming requests, combined with a library of
    known commands with which to respond.
    """
    def __init__(self,server,Command=None,owner=None):
        self.server = server
        if Command!=None:
            self.queue=[Command]
        else: 
            self.queue=[]
        if owner!=None: 
            self.owner=owner

    def get_next_command(self):
        '''
        Get compile active_xtsm asap, otherwise, other priority commands
        '''
        for command in self.queue:
            if not hasattr(command, 'command'):
                continue
            if not hasattr(command.command, 'has_key'):
                continue
            if not command.command.has_key('IDLSocket_ResponseFunction'):
                continue
            if command.command['IDLSocket_ResponseFunction'] == 'compile_active_xtsm':
                compile_command = command
                self.queue.remove(compile_command)
                return compile_command
            else:
                continue
            
        return self.queue.pop()
            
            
    
    def add(self,command):
        if DEBUG and command.command != self.server.server_ping and command.command != self.server.catch_ping: print "class Queue, function add"
        #pdb.set_trace()
        #print command.command      
        if isinstance(  command , ServerCommand):
            #print "This is a ServerCommand"
            pass
            #pdb.set_trace()
        self.queue.append(command)
        #print "class Queue, function add - End"
    def popexecute(self):
        #if DEBUG: print "class Queue, function popexecute"
        if len(self.queue) > 0:
            command = self.get_next_command()
            if DEBUG and command.command != self.server.server_ping and command.command != self.server.catch_ping: print "Executing top of Queue"
            command.execute(self.server.command_library)
            #print "Executing top of Queue - End"
    def xstatus(self):
        stat="<Commands>"
        if hasattr(self,'queue'):
            for command in self.queue:
                stat += '<Command>'
                try:
                    statd = ''
                    statd += "<Name>"
                    statd += command.params['IDLSocket_ResponseFunction']
                    statd += "</Name>"
                    for param in command.params:
                        statd += "<Parameter>"
                        statd += "<Name>" + param + "</Name>"
                        statd += "<Value>"
                        statd += "<![CDATA["
                        statd += command.params[param][0:25]
                        statd += "]]>"
                        statd += "</Value>"
                        statd += "</Parameter>"
                    stat += statd
                except: stat += "<Updating></Updating>"
                stat += '</Command>'
        stat += "</Commands>"
        return stat

class CommandLibrary():
    """
    The Command Library contains all methods a server can execute in response
    to an HTTP request; the command is specified by name with the 
    "IDLSocket_ResponseFunction" parameter in an HTTP request
    Note: it is the responsibility of each routine to write responses
    _AND CLOSE_ the initiating HTTP communication using
    params>request>protocol>loseConnection()
    """
    def __init__(self, server):
        if DEBUG: print "class CommandLibrary, func __init__"
        self.server = server
        
    def __determineContext__(self,params):
        if DEBUG: print "class CommandLibrary, func __determineContext__"
        #print params
        if not params.has_key('data_context'):
            ip_address = ''
            try:
                ip_address = params['request']['protocol'].peer.split(":")[0]
            except KeyError:
                if DEBUG: print "Error: class CommandLibrary, func __determineContext__"
                pdb.set_trace()
                raise
            default_dc_name = "default:" + ip_address
            dcname = default_dc_name
            if ip_address == '127.0.0.1':
                dcname = 'default:' + self.server.ip
            if not self.server.dataContexts.has_key(dcname):
                dc = sync.DataContext(dcname, self.server)
                self.server.dataContexts.update({dcname:dc})
            if DEBUG: print "dcname:",dcname
            return self.server.dataContexts[dcname]
            
        dcname = params['data_context']
        if not self.server.dataContexts.has_key(dcname):
            dc = sync.DataContext(dcname, self.server)
            self.server.dataContexts.update({dcname:dc})
        if DEBUG: print "dcname:",dcname
        return self.server.dataContexts[dcname]
        
        '''
        old function:
        print "class CommandLibrary, func __determineContext__"
        print params
        try: 
            dcname = params['data_context']
            if dcname == 'exp_sync':
                dcname = 'default:10.1.1.136'
            #print "dcname:", dcname
            if not params['request']['protocol'].server.dataContexts.has_key(dcname):
                raise KeyError
        except KeyError:
            # look for a default data context for this IP address, if none, create
            #pdb.set_trace()
            dcname = "default:"+params['request']['protocol'].peer.split(":")[0]
            if params['request']['protocol'].peer.split(":")[0] == '127.0.0.1':
                dcname = "default:"+self.server.ip
            if not params['request']['protocol'].server.dataContexts.has_key(dcname):
                dc = DataContext(dcname, self.server)
                params['request']['protocol'].server.dataContexts.update({dcname:dc})
        print "dcname:",dcname
        return params['request']['protocol'].server.dataContexts[dcname]
        '''        
        
    # below are methods available to external HTTP requests - such as those required
    # by experiment GUI and timing system to implement basic functions of timing system
    # all must accept a single dictionary argument params, containing arguments of HTTP request
    # and an item 'request', which contains data on HTTP request and a reference to the twisted
    # protocol instance handling the response
    def set_global_variable_from_socket(self,params):
        """
        sets a variable by name in the caller's data context
        """
        if DEBUG: print "class CommandLibrary, func set_global_variable_from_socket"
        #print params
        #pdb.set_trace()

        if params.has_key('variable_name'):
            self.post_active_xtsm(params)
            
        
        if params.has_key('IDLSPEEDTEST'):
            srtime = time.time()
            """
            These write functions may crash any websocket connections that it
            tries to write into since it may not be json
            """
            params['request']['protocol'].transport.write(params['IDLSPEEDTEST'])
            ertime = time.time()
            params['request']['protocol'].transport.write(str(srtime-params['request']['ctime'])+','+str(ertime-srtime)+','+str(params['request']['timereceived']-params['request']['ctime'])+',0,0,0')      
            params['request']['protocol'].transport.loseConnection()
            return
        try: 
            varname=set(params.keys()).difference(set(['IDLSocket_ResponseFunction',
                                                       'terminator',
                                                       'request',
                                                       'data_context'])).pop()
        except KeyError:
            params['request']['protocol'].transport.write('Error: Set_global requested, but no Variable Supplied')
            params['request']['protocol'].transport.loseConnection()
            return
        if varname!='_active_xtsm':
            dc=self.__determineContext__(params)
            dc.update({varname:params[varname]})
            params['request']['protocol'].transport.write(str(varname)+
                                                              ' updated at ' +
                                                              time.strftime("%H:%M:%S") +
                                                              '.' )
            params['request']['protocol'].transport.loseConnection()
            return
        else:
            self.post_active_xtsm(params)

#Loopiong Call, under server.chck for new image on cameradatabomb -> databomb dispatcher - 
        #dispatcher periodically called bvia looping call and the dispatcher periodically sends it off. - 1s eg.
        #add function in command library that gets all instrucments attached to that server. - children of GLabInstrument.
        #second function in command library that adds you as a destination to the databomb dispatcher. - send it back over the client websocket.
        #databomb dispatcher is also a member objct of the Server.
        

    def scan_instruments(self):
        interested_instruments = []
        for dc in self.server.dataContexts:
            for key in dc:
                if isinstance(dc[key], glab_instrument.Glab_Instrument):
                    interested_instruments.append(dc[key])
                    
        return interested_instruments
        
        
        #End Test

    def announce_listener(self,params):
        if DEBUG: print "class server, function announce_listener"
        self.server.DataBombDispatcher.link_to_instrument(params)
        #send back errors - return fail - ie no instrument.


    def get_global_variable_from_socket(self,params):
        """
        gets a variable by name from the caller's data context
        """
        """
        These write functions may crash any websocket connections that it
        tries to write into since it may not be json
        """
        print "class CommandLibrary, func get_global_variable_from_socket"
        try:
            varname=params['variablename']
            dc=self.__determineContext__(params)
            # A special case is required for XTSM, as it will return an object, not a string, if it is not cantented to another string.
            params['request']['protocol'].transport.write(str(dc.get(varname)))
            params['request']['protocol'].transport.loseConnection()
        except KeyError:
            params['request']['protocol'].transport.write('Error: get_global requested, but no variable name supplied')
            params['request']['protocol'].transport.loseConnection()

    def ping_idl_from_socket(self,params):
        """
        These write functions may crash any websocket connections that it
        tries to write into since it may not be json
        """
        params['request']['protocol'].transport.write('ping')
        params['request']['protocol'].transport.loseConnection()

    def get_server_status(self,params):
        """
        These write functions may crash any websocket connections that it
        tries to write into since it may not be json
        """
        params['request']['protocol'].transport.write(params['request']['protocol'].factory.parent.xstatus())
        params['request']['protocol'].transport.loseConnection()

    def get_data_contexts(self,params):
        """
        Gets all data contexts from the server and sends the key under which each is stored.
        """
        """
        These write functions may crash any websocket connections that it
        tries to write into since it may not be json
        """
        print "class CommandLibrary, func get_data_contexts"
        for dc in params['request']['protocol'].factory.parent.dataContexts:
            params['request']['protocol'].transport.write(str(dc) + ',')
        params['request']['protocol'].transport.loseConnection()

    def execute_script(self,params):
        self.server.execute_script(params)

    def execute_from_socket(self,params):
        """
        Executes an arbitrary python command through the socket, and returns the console
        output
        """
        """
        These write functions may crash any websocket connections that it
        tries to write into since it may not be json
        """
        print "class CommandLibrary, func execute_from_socket"
        dc=self.__determineContext__(params).dict
        # setup a buffer to capture response, temporarily grab stdio
        params['request']['protocol'].transport.write('<Python<           '+params['command']+'\n\r')        
        rbuffer = StringIO()
        sys.stdout = rbuffer
        try: exec(params['command'],dc)
        except:
            """
            These write functions may crash any websocket connections that it
            tries to write into since it may not be json
            """
            params['request']['protocol'].transport.write('>Python>   ERROR\n\r')
            params['request']['protocol'].transport.loseConnection()
            return
        # exec command has side-effect of adding builtins; remove them
        if dc.has_key('__builtins__'): 
            del dc['__builtins__']
        # update data context
        # remember to restore the original stdout!
        sys.stdout = sys.__stdout__ 
        # requests variables from the directory and writes to user.
        params['request']['protocol'].transport.write('>Code>')
        for var in dc:
            params['request']['protocol'].transport.write('>Var>' + var + ' is ' + str(type(var)) + ' and is equal to ' + str(dc[var]))
        params['request']['protocol'].transport.write('>Code>')
        # output the response buffer to the HTTP request
        params['request']['protocol'].transport.write('>Python>   '+rbuffer.getvalue()+'\n\r')
        params['request']['protocol'].transport.loseConnection()
        rbuffer.close()

    def post_active_xtsm(self, params):
        """
        Posts the active xtsm string that will be used for all subsequent calls
        from timing systems
        """
        if DEBUG: print "class CommandLibrary, func post_active_xtsm"
        dc = self.__determineContext__(params)
        try: 
            exp_sync = dc.get('_exp_sync')        
        except: 
            exp_sync = sync.Experiment_Sync_Group(self.server, dc.name)
            dc.update({'_exp_sync':exp_sync})
        ax = params['_active_xtsm']
        ax = XTSM_Transforms.strip_to_active(ax)
        exp_sync.active_xtsm = ax
        #pdb.set_trace()
        if params.has_key('socket_type'):
            if params['socket_type'] == 'Websocket':
                message = {'server_console':'Active XTSM updated at ' + time.strftime("%H:%M:%S") + '.' , 'data_context': dc.name}
                json = simplejson.dumps(message, ensure_ascii = False).encode('utf8')
                params['request']['protocol'].sendMessage(json)
                #params['request']['protocol'].sendMessage(message)
        else:
            params['request']['protocol'].transport.write('Active XTSM updated at ' + time.strftime("%H:%M:%S") + '.' )
            params['request']['protocol'].transport.loseConnection()

    def request_xtsm(self,params):
        """
        Retrieves and returns xtsm by shotnumber
        """
        if DEBUG: print "class CommandLibrary, func request_xtsm"
        if DEBUG: print params
        dc = self.__determineContext__(params)
        message = 'XTSM requested, but shot number does not exist'
        '''
        Added to make work CP. To fix, need to change the gui query.
        '''
        try: 
            exp_sync = dc.get('_exp_sync')
        except:
            pdb.set_trace()
            params.update({'data_context':params['data_context']})
            dc = self.__determineContext__(params)
        '''
        End addition CP
        '''
        #pdb.set_trace()
        
        try: 
            exp_sync = dc.get('_exp_sync')
        except KeyError:
            msg = "KeyError: No _exp_sync in data_context. params:", params
            self._respond_and_close(params,msg)
            if DEBUG: print msg
            return
        try:
            try:
                sn = int(params['shotnumber'])
            except ValueError:
                print "Error: Bad Shotnumber", params
                return
            xtsm = exp_sync.compiled_xtsm[sn].XTSM
            print sn
            #pdb.set_trace()
            msg = {"xtsm":xtsm.write_xml(),"shotnumber":sn,"data_context":params['data_context']}
            #xtsm = exp_sync.compiled_xtsm[int(params['shotnumber'])].XTSM
            #msg = {"xtsm":xtsm.write_xml(),"shotnumber":int(params['shotnumber'])}
            reqxtsm = simplejson.dumps({"xtsm_return":simplejson.dumps(msg),"data_context":params['data_context']})
            #print reqxtsm
        except KeyError: 
            try:
                msg = '{"server_console":"'+message+'"}'
                params['request']['write'](msg)
                if DEBUG: print "KeyError: params:", params, "msg:", msg
            except KeyError: 
                params['request']['protocol'].transport.write(message)
                params['request']['protocol'].transport.loseConnection()
                if DEBUG: print "KeyError: params:", params, "message:", message
        try:
            
            try:
                print "Sending xtsm to GUI"
                params['request']['protocol'].sendMessage(reqxtsm)
                print "Sent xtsm to GUI"
            except:
                print "Error, didn't use websocket well"
                params['request']['write'](reqxtsm)
            
            #params['request']['write'](reqxtsm)
            pass
            #pdb.set_trace()
        except KeyError: 
            """
            These write functions may crash any websocket connections that it
            tries to write into since it may not be json
            """
            params['request']['protocol'].transport.write(reqxtsm)
            params['request']['protocol'].transport.loseConnection()
            if DEBUG: print "KeyError: params:", params
        except UnboundLocalError:
            pass
            if DEBUG: print "UnboundLocalError: GUI tried to search for shotnumber that doesn't exist. params:", params
            #pdb.set_trace()
            

    def compile_active_xtsm(self, params):
        """
        Compiles the active xtsm in the current data context for requestor,
        and returns the timingstring to the requestor through the html response
        
        the current context is with highest priority the one specified by the
        "data_context" element in the caller's request, with next highest the 
        context assigned to the requester by default, and with next highest the
        first datacontext retrieved with a "pxi_data_context" element naming
        the requester's data context.  If any are missing the _exp_sync element
        containing the active_xtsm string and shotnumber, they are skipped.
        
        First the PXI system sends a request for the parsed xtsm via,
        "IDLSocket_ResponseFunction:compile_active_xtsm", the server then
        parses the data_context's "_active xtsm". After parsing, the server
        broadcasts the parsed xtsm out to all connected websocket connections.
        Then any parameters that need to be posted to the data_context are set,
        data_listeners are generated, scripts are executed/sent off. At the end,
        track changes to the xtsm, and then finally send the timingstrings back
        to the PXI.
        """
        if DEBUG and not len(params) < 10000: print params
        # mark requestor as an XTSM compiler
        if DEBUG: print "In class CommandLibrary, function compile_active_xtsm", "time:", float(time.time()) - 1412863872
        
        self.server.connection_manager.update_client_roles(params['request'],'active_XTSM_compiler')

        dc = self.__determineContext__(params)
        if not dc.dict.has_key('_exp_sync'):
            msg = {"server_console": 
                str(params['request']['protocol'].peer.split(":")[0]) +
                ' requested timing data in data_context: ' + dc.name +
                ', but nothing is assigned to run on this system.',
                "data_context": dc.name}
            print "Error:", str(msg)
            self.server.broadcast(simplejson.dumps(msg, ensure_ascii = False).encode('utf8'))
            return
                    
        # get the experiment synchronization object; set the shotnumber
        exp_sync = dc.get('_exp_sync')
        exp_sync.shotnumber = int(params['shotnumber'])
        sn = exp_sync.shotnumber
        
        # turn the active_xtsm string into an object
        xtsm_object = XTSMobjectify.XTSM_Object(exp_sync.active_xtsm)
        dc.update({'_active_xtsm_obj':xtsm_object})
        
        # parse the active xtsm to produce timingstrings
        message = {"server_console": 
        "Started parsing shotnumber " + str(sn) + " at " + str(datetime.now()),
         "data_context": dc.name}
        self.server.broadcast(simplejson.dumps(message, ensure_ascii = False).encode('utf8'))
        
        if not hasattr(xtsm_object, 'XTSM'):
            if DEBUG: print "Error: No xtsm_object.XTSM:"
            if DEBUG: print params, xtsm_object
            self.server.bad_xtsm = xtsm_object
            return
        if not hasattr(xtsm_object.XTSM, 'head'):
            if DEBUG: print "Error: No head in xtsm_object.XTSM:"
            if DEBUG: print params, xtsm_object.XTSM.write_xml()
            self.server.bad_xtsm = xtsm_object
            return
        XTSMobjectify.preparse(xtsm_object)
        t0 = time.time()
        parserOutput = xtsm_object.parse(sn)
        tp = time.time()
        XTSMobjectify.postparse(parserOutput)            
        t1 = time.time()
        if DEBUG: print "Parse Time: " , t1-t0, "s", "(postparse ", t1-tp, " s)"
        
        message = {"server_console":
            "Finished parsing shotnumber " + str(sn) + " at " + str(datetime.now()),
            "data_context": dc.name}
        message = simplejson.dumps(message, ensure_ascii = False).encode('utf8')
        self.server.broadcast(message)
       
                                
        #pdb.set_trace()
        #Setting parameters:
        for par in xtsm_object.XTSM.getDescendentsByType("Parameter"):
            if hasattr(par,"PostToContext"):
                if par.PostToContext.PCDATA == 'True':
                    try:
                        dc.update({par.Name.PCDATA:par.Value.parse()})
                    except Exception as e:
                        par.addAttribute("parser_error", str(e))

        # setup data listeners for returned data
        #pdb.set_trace()
        if (not dc.dict.has_key('_bombstack')):
            dc.update({'_bombstack':DataBomb.DataBombCatcher()})
        if (not hasattr(dc['_bombstack'],'dataListenerManagers')):
            setattr(dc['_bombstack'],
                        'dataListenerManagers',
                        DataBomb.DataListenerManager()) 
                        
        #Setting analysis stream
        if (not dc.dict.has_key('_analysis_stream')):
            #p = {'file_root_selector':'analysis_stream'}
            p = {'filestream_folder':'analysis_stream'}
            dc.update({'_analysis_stream':InfiniteFileStream.Filestream(params=p)})
        xtsm_object.XTSM._analysis_stream = dc['_analysis_stream']
        
        #Get and execute scripts in the XTSM
        active_sequence = xtsm_object.XTSM.getActiveSequence()
        #pdb.set_trace()
        for script in active_sequence.getDescendentsByType('Script'):
            if hasattr(script, 'Remote'):
                if script.Remote.PCDATA != 'False':
                    if script.Remote.PCDATA != str(self.server.ip):
                        script.dispatch(self.server)
                        continue
            script._find_dependencies(self.server)
            
        xtsm_object.installListeners(dc['_bombstack'].dataListenerManagers)
        #This calls _generate_listeners_ and passes in the DLM instance.
        #InstallListeners passes the return of __generate_listeners__ to spawn in DLM class
        # InstrumentCommands       
        #pdb.set_trace()
            
        '''
        #Dispatch all scripts, - Scripts in InstrumentCommand is in a subset
            #of all Scripts - so, dispatch all Scripts first
        #Need to find the InstrumentCommand for the current sequence 

        commands = xtsm_object.XTSM.getDescendentsByType("InstrumentCommand")#Need to dispatch all scripts. Change This CP
        for c in commands:
            c.Script.dispatch(self.server)
                    #return
                #Also need to change the passing in of a script body to actually have those lines of code.
                #Then in the GUI we can make a text box so the code is visible,
                #And - if there gets to be lots of code, it can be put into the "Roper_CCD" class as a function to call.
        '''    
        
        if DEBUG: print "xtsm_return, sn:", sn
        message = {"data_context": dc.name,
                   "xtsm_return":
                   simplejson.dumps({"shotnumber":int(sn),
                   "xtsm":xtsm_object.XTSM.write_xml()},
                     ensure_ascii = False).encode('utf8')}
        message = simplejson.dumps(message, ensure_ascii = False).encode('utf8')
        self.server.broadcast(message)             
            
        # attach the xtsm object that generated the outgoing control arrays to the experiment sync's xtsm_stack
        dc['_exp_sync'].compiled_xtsm.update({sn:xtsm_object})
        dc['_exp_sync'].last_successful_xtsm = exp_sync.active_xtsm

        # begin tracking changes to the xtsm_object
        def _changed_xtsm(changedelm):
            message = {"data_context": dc.name,
                       "xtsm_return":
                       simplejson.dumps({"shotnumber":int(sn),
                       "xtsm":xtsm_object.XTSM.write_xml()},
                         ensure_ascii = False).encode('utf8')}
            message = simplejson.dumps(message, ensure_ascii = False).encode('utf8')
            self.server.broadcast(message)   
        xtsm_object.XTSM.onChange = _changed_xtsm

        # send back the timingstrings
        timingstringOutput = str(bytearray(parserOutput.package_timingstrings()))
        #print parserOutput.timing_string_ints
        #pdb.set_trace()
        if DEBUG: print "timingstringOutput, at time:", float(time.time()) - 1412863872
        msg = simplejson.dumps({"sending":"timingstring"}, ensure_ascii = False).encode('utf8')
        if params.has_key('socket_type'):
            #Right now just for PXI_emulator
            if params['socket_type'] == 'Websocket':
                params['request']['protocol'].sendMessage(msg)
                pass
            else:
                pass
                #params['request']['protocol'].transport.loseConnection()
        else:
            #Actually sending the timingstrings to the PXI system
            params['request']['protocol'].transport.write(timingstringOutput)
            params['request']['protocol'].transport.loseConnection()
        

        



    def testparse_active_xtsm(self, params):
        """
        Parses the active_xtsm and posts the processed xtsm in the current data context
        as _testparsed_xtsm, as well as returns it to the requester as an xml string
        """
        if DEBUG: print "In class CommandLibrary, function testparse_active_xtsm"
        dc = self.__determineContext__(params)  # gets the calling command's data context
        parent_dc = ''  # begins looking for the pxi system's data context
        for name, pdc in params['request']['protocol'].factory.parent.dataContexts.iteritems():
            try:
                if dc.get('__context__') == pdc.get('pxi_data_context'):
                    parent_dc = pdc
            except KeyError:
                pass

        if parent_dc=='':
            parent_dc = dc  # if there is no pxi data context, revert to caller's
        active_xtsm = parent_dc.get('_active_xtsm')  # retrieve the xtsm code currently active
        try:
            sn = parent_dc.get('_shotnumber')
        except AttributeError:
            sn = 0

        xtsm_object = XTSMobjectify.XTSM_Object(active_xtsm)
        if DEBUG: print "Started parsing shotnumber =", sn, "at", datetime.now()
        XTSMobjectify.preparse(xtsm_object)
        parserOutput = xtsm_object.parse(sn)
        XTSMobjectify.postparse(parserOutput)
        if DEBUG: print "Finished parsing shotnumber =", sn, "at", datetime.now()

        timingstringOutput = str(bytearray(parserOutput.package_timingstrings()))
        # create timingstring even though it isn't used
        
        parsed_xtsm = xtsm_object.XTSM.write_xml()
        dc.update({'_testparsed_xtsm':parsed_xtsm})
        """
        These write functions may crash any websocket connections that it
        tries to write into since it may not be json
        """
        params['request']['protocol'].transport.write(str(parsed_xtsm))
        params['request']['protocol'].transport.loseConnection()

    def databomb(self, params):
        """
        dumps a messagepack data bomb into current data context's bombstack
        this is a method for data collection hardware to report data into
        the webserver to be stored to disk, associated with the generating XTSM,
        and for analyses to be initiated 
        """
        if DEBUG: print "dealing with data bomb that came back"
        #print self.server.dataContexts['default:127.0.0.1'].dict['_bombstack'].dataListenerManagers.listeners #This is the context that has the listeners
        #pdb.set_trace()
        
        dc=self.__determineContext__(params)
        if DEBUG: print "dc.dict['_bombstack'].dataListenerManagers.listeners", dc.dict['_bombstack'].dataListenerManagers.listeners#Should have listeners installed
        if (not dc.dict.has_key('_bombstack')):
            dc.update({'_bombstack':DataBomb.DataBombCatcher()})
        # data listeners should be attached under the bombstack!!
        # if (not dc.dict.has_key('dataListenerManagers')): dc.update({'dataListenerManagers':DataBomb.DataListenerManager()})
        if (not hasattr(dc['_bombstack'],'dataListenerManagers')):
            setattr(dc['_bombstack'],
                    'dataListenerManagers',
                    DataBomb.DataListenerManager())

        
        bomb_id=dc['_bombstack'].add(DataBomb.DataBomb(params['databomb']))
        msg = {'Not_Command_text_message':'databomb ' + bomb_id + ' updated at ' + time.strftime("%H:%M:%S") + '.','terminator':'die'}
        #msg = {'Not_Command_text_message':'hi','terminator':'die'}        
        #pdb.set_trace()
        if DEBUG: print "dc.get('_bombstack').dataListenerManagers.listeners", dc.get('_bombstack').dataListenerManagers.listeners
        #This closes the ws connection - I don't know why - CP       
        #params['request']['protocol'].transport.write(simplejson.dumps(msg, ensure_ascii = False).encode('utf8'))
        if str(params['request']['protocol'].transport.getPeer().port) != str(wsport):
            pass
            #This closes the ws connection - I don't know why - CP 
            #params['request']['protocol'].transport.loseConnection()
            
        # next line adds a deployment command to the command queue
        #This should be moved into the Databomb class
        self.server.command_queue.add(ServerCommand(self.server,dc['_bombstack'].deploy,bomb_id))
        #self.temp_plot(params, bomb_id, dc)
        #self.temp_plot_oneframe(params, bomb_id,dc) #LRJ 10-21-2014 _oneframe
        #pdb.set_trace()
        #self.temp_plot_qt(params, bomb_id,dc)
        #self.server.send_to_data_gui()
        #pdb.set_trace()
        
        #raw_databomb = msgpack.unpackb(params['databomb'])
        #self.server.databombs_for_data_gui.update({str(raw_databomb['shotnumber']):params['databomb']})
        
        self.temp_plot(params, bomb_id,dc)
        #pdb.set_trace()
        
        '''
        raw_databomb = msgpack.unpackb(params['databomb'])
        sn = raw_databomb['shotnumber']
        xtsm = exp_sync.compiled_xtsm[sn].XTSM
        dc._exp_sync.compiled_xtsm.
        active_sequence = xtsm_object.XTSM.getActiveSequence()
        '''
        
        packed_message = msgpack.packb({"IDLSocket_ResponseFunction":'plot_and_save_fluoresence_image',
                                        'data_context':dc.name,
                                        'packed_databomb':params['databomb']},
                                         use_bin_type=True)  
        
        for p in self.server.connection_manager.data_gui_servers:
            self.server.send(packed_message,self.server.connection_manager.data_gui_servers[p], isBinary=True)        
        
        
    def temp_plot_qt(self,params,bomb_id, dc):
        print "plotting"
        raw_databomb = msgpack.unpackb(params['databomb'])
        fig = plt.figure(figsize=(18, 12))  
        ax = fig.add_subplot(221)
        #pdb.set_trace()
        raw_img_data = raw_databomb['data']
        num_pics = len(raw_img_data)
        corrected_image = [[]]
        if num_pics != 0:
            if num_pics == 3:
                #print "three frames"prindd
                corrected_image = np.subtract(np.asarray(raw_img_data[1],dtype=int),
                                              np.asarray(raw_img_data[2],dtype=int))
            else:
                print "Not Supported"
                return
                raise
        #min_scale = 65536
        max_scale_zoom = -50
        min_scale_zoom = 30*1000
        max_scale_full = -50
        min_scale_full = 30*1000
        if dc.dict.has_key('ImageScaleZoomMax'):
            max_scale_zoom = dc['ImageScaleZoomMax']
        if dc.dict.has_key('ImageScaleZoomMin'):
            min_scale_zoom = dc['ImageScaleZoomMin']
        if dc.dict.has_key('ImageScaleFullMax'):
            max_scale_full = dc['ImageScaleFullMax']
        if dc.dict.has_key('ImageScaleFullMin'):
            min_scale_full = dc['ImageScaleFullMin']
            

        pix = 512
        frame1 = numpy.asarray(numpy.random.rand(pix,pix).tolist())
        frame2 = numpy.asarray(numpy.random.rand(pix,pix).tolist())

        app = QtGui.QApplication([])
        win = QtGui.QMainWindow()
        win.resize(800,800)
        imv = pg.ImageView()
        win.setCentralWidget(imv)
        win.show()
        img = numpy.random.normal(size=(pix, pix)) * 20 + 100
        img = frame1
        img = img[numpy.newaxis,:,:]
        data = numpy.asarray([frame1,frame2])
        imv.setImage(data)
        
        if (sys.flags.interactive != 1) or not hasattr(QtCore, 'PYQT_VERSION'):
            QtGui.QApplication.instance().exec_()
        
        
    def temp_plot(self, params, bomb_id,dc):
                
        raw_databomb = msgpack.unpackb(params['databomb'])
        #hdf5_liveheap.glab_liveheap
        #file_storage = hdf5_liveheap.glab_datastore()
        #file_storage.
                
        
        fig = plt.figure(figsize=(18, 12))  
        ax = fig.add_subplot(221)
        #pdb.set_trace()
        raw_img_data = raw_databomb['data']
        num_pics = len(raw_img_data)
        corrected_image = [[]]
        if num_pics != 0:
            if num_pics == 1:
                print "one frame"
                corrected_image = numpy.subtract(numpy.asarray(raw_img_data[0],dtype=int), rdn.darkavg)
            elif num_pics == 2:
                print "two frames"
                #corrected_image = np.subtract(np.asarray(raw_img_data[1],dtype=int),
                #                              np.asarray(raw_img_data[0],dtype=int))
                corrected_image= numpy.subtract(numpy.asarray(raw_img_data[1],dtype=int), rdn.darkavg)               
            elif num_pics == 3:
                #print "three frames"prindd
#                corrected_image = np.log(np.divide(np.asarray(raw_img_data[1],dtype=float),
#                                              np.asarray(raw_img_data[2],dtype=float)))
                 corrected_image = numpy.subtract(numpy.asarray(raw_img_data[1],dtype=numpy.float),numpy.asarray(raw_img_data[2],dtype=numpy.float))
                 msg = {'shotnumber':raw_databomb['shotnumber'], 'data':corrected_image }
                 packed_message = msgpack.packb(msg , use_bin_type=True)
                 self.server.databomblist.append(packed_message) #add by Jz to create a list of databombs for imageviewer
                 #thresh_image = np.divide(np.asarray(raw_img_data[1],dtype=int),np.asarray(raw_img_data[2],dtype=int))
               
            else:
                print "Not Supported"
                return
                raise
        #min_scale = 65536
        
        max_scale_zoom = 5000
        min_scale_zoom = -100
        max_scale_full = 7000
        min_scale_full = -100       
        
        if dc.dict.has_key('ImageScaleZoomMax'):
            max_scale_zoom = dc['ImageScaleZoomMax']
        if dc.dict.has_key('ImageScaleZoomMin'):
            min_scale_zoom = dc['ImageScaleZoomMin']
        if dc.dict.has_key('ImageScaleFullMax'):
            max_scale_full = dc['ImageScaleFullMax']
        if dc.dict.has_key('ImageScaleFullMin'):
            min_scale_full = dc['ImageScaleFullMin']
        
        
        #bottom_left_coord = (120,345)
        #top_right_coord = (340,180)
        bottom_left_coord = (300,150)#(x,y)
        top_right_coord = (350,100)
        #bottom_left_coord = (260,165)
        #top_right_coord = (271,185)
        region_of_interest = corrected_image[top_right_coord[1]:bottom_left_coord[0],
                                             bottom_left_coord[1]:top_right_coord[0]]
        #region_of_interest = corrected_image[180:350, #down, specify bottom,
        #                                     120:350]#second number is how far accross
        #pdb.set_trace()
        self.server.ALL_DATABOMBS.update({str(raw_databomb['shotnumber']):[raw_img_data[0],raw_img_data[1],raw_img_data[2]]})
        cax = ax.imshow(numpy.asarray(raw_img_data[1],dtype=float), cmap = mpl.cm.Greys_r,vmin=min_scale_full, vmax=max_scale_full, interpolation='none')#, cmap = mpl.cm.spectral mpl.cm.Greys_r)   
        cbar = fig.colorbar(cax)
        
        ax2 = fig.add_subplot(232)
        cax2 = ax2.imshow(numpy.asarray(raw_img_data[2],dtype=float), cmap = mpl.cm.Greys_r,vmin=min_scale_full, vmax=max_scale_full,interpolation='none')#, cmap = mpl.cm.spectral mpl.cm.Greys_r)                   

        ax3 = fig.add_subplot(233)
        cax3 = ax3.imshow(corrected_image, cmap = mpl.cm.Greys_r,vmin=min_scale_zoom, vmax=max_scale_zoom,interpolation='none')#, cmap = mpl.cm.spectral mpl.cm.Greys_r)                   
        cbar3 = fig.colorbar(cax3)

        ax4 = fig.add_subplot(234)
        cax4 = ax4.imshow(region_of_interest, cmap = mpl.cm.Greys_r,vmin=min_scale_zoom, vmax=max_scale_zoom,interpolation='none')#, cmap = mpl.cm.spectral mpl.cm.Greys_r)                   
        num_atoms = float(region_of_interest.sum()) * 303 * pow(10,-6) * 0.7
        cbar4 = fig.colorbar(cax4)
        
        self.server.sum_arr=numpy.append(self.server.sum_arr,float(region_of_interest.sum()))
        
        '''        
        ax5 = fig.add_subplot(235)
        cax5 = ax5.imshow(thresh_image, cmap = mpl.cm.Greys_r,vmin=0, vmax=2,interpolation='none')#, cmap = mpl.cm.spectral mpl.cm.Greys_r)                   
        cbar5 = fig.colorbar(cax5)
        '''
        
        '''
        numrows, numcols = corrected_image.shape
        def format_coord(x, y):
            col = int(x+0.5)
            row = int(y+0.5)
            if col>=0 and col<numcols and row>=0 and row<numrows:
                z = corrected_image[row,col]
                return 'x=%1.4f, y=%1.4f, z=%1.4f'%(x, y, z)
            else:
                return 'x=%1.4f, y=%1.4f'%(x, y)

        ax.format_coord = format_coord 
        ax2.format_coord = format_coord 
        ax3.format_coord = format_coord 
        

        numrows, numcols = corrected_image.shape
        ax4.format_coord = format_coord       
        '''
        
        #path = file_locations.file_locations['raw_buffer_folders'][uuid.getnode()]+'/'+date.today().isoformat()
        path = '..\\psu_data\\'+date.today().isoformat() + '\\raw_data\\'
        file_name = 'databomb_' + bomb_id + '_at_time_' + str(raw_databomb['packed_time'])
        plt.title("SN="+str(raw_databomb['shotnumber'])+'\n_'+path+'\n/'+file_name+' Counts = '+str(float(region_of_interest.sum())), fontsize=10)
        #plt.title("SN="+str(raw_databomb['shotnumber'])+' Counts = '+ str(region_of_interest.sum()), fontsize=10)
       #reactor.callInThread(plt.show,'block=False')
        #reactor.callFromThread(plt.close)
        #subtracted image
        plt.show(block=False)
                
        '''        
        f = open(path+'/'+file_name+'.txt', 'w')
        pickle.dump(corrected_image,f)
        f.close()
        #first raw image
        f = open(path+'/'+file_name+'_raw_img1.txt', 'w')
        pickle.dump(raw_img_data[0],f)
        f.close()
        #second raw image
        f = open(path+'/'+file_name+'_raw_img2.txt', 'w')
        pickle.dump(raw_img_data[1],f)
        f.close()
        #third raw image
        f = open(path+'/'+file_name+'_raw_img3.txt', 'w')
        pickle.dump(raw_img_data[2],f)
        f.close()
        '''        
        #print "--> Data pickled to:", path+'/'+file_name+'.txt'
        #plt.savefig(path+'/'+file_name+'.svg')
        plt.savefig(path+'/'+file_name+'.png')
        print "Shotnumber:", str(raw_databomb['shotnumber'])
        #print "Path to saved picture/data:", str(path+'/'+file_name+'.txt')
        #plt.close()
        
        # mark requestor as a data generator
        #pdb.set_trace()
       
    def temp_plot_oneframe(self, params, bomb_id,dc):
        
        raw_databomb = msgpack.unpackb(params['databomb'])
        #hdf5_liveheap.glab_liveheap
        #file_storage = hdf5_liveheap.glab_datastore()
        #file_storage.
                
        
        fig = plt.figure(figsize=(18, 12))  
        ax = fig.add_subplot(221)  
        
        #pdb.set_trace()
        raw_img_data = raw_databomb['data']
        num_pics = len(raw_img_data)
        corrected_image = raw_img_data[0]
       
      
        
        
        '''
        numrows, numcols = corrected_image.shape
        def format_coord(x, y):
            col = int(x+0.5)
            row = int(y+0.5)
            if col>=0 and col<numcols and row>=0 and row<numrows:
                z = corrected_image[row,col]
                return 'x=%1.4f, y=%1.4f, z=%1.4f'%(x, y, z)
            else:
                return 'x=%1.4f, y=%1.4f'%(x, y)
       '''
       
        max_scale=1200
        #max_scale=np.amax(corrected_image)
        min_scale=numpy.amin(corrected_image)
        #min_scale=0
        cax = ax.imshow(numpy.asarray(corrected_image,dtype=float), cmap = mpl.cm.Greys_r,vmin=min_scale, vmax=max_scale, interpolation='none')#, cmap = mpl.cm.spectral mpl.cm.Greys_r)   
        cbar = fig.colorbar(cax)
        
        #path = file_locations.file_locations['raw_buffer_folders'][uuid.getnode()]+'/'+date.today().isoformat()
        path = '..\\psu_data\\'+date.today().isoformat() + '\\raw_data\\'
        file_name = 'databomb_' + bomb_id + '_at_time_' + str(raw_databomb['packed_time'])
        plt.title("SN="+str(raw_databomb['shotnumber']), fontsize=10)
        plt.show(block=False)
               
     
        plt.savefig(path+'/'+file_name+'.png')
        print "Shotnumber:", str(raw_databomb['shotnumber'])
        #print "Path to saved picture/data:", str(path+'/'+file_name+'.txt')
        #plt.close()
        
        # mark requestor as a data generator
        #pdb.set_trace()    
        
    

    def stop_listening(self,params):
        """
        Exit routine, stops twisted reactor (abruptly).
        """
        if DEBUG: print "Closing Python Manager"
        broadcastMessage = "Python Manager Shutting Down on Request."
        self.server.broadcast('{"server_console":'+broadcastMessage+', "data_context":"' + params['data_context'] + '"}')
        msg = {'Not_Command_text_message':"Closing Python Manager - Goodbye.",'terminator':'die'}
        try:
            params['request']['write'](simplejson.dumps(msg, ensure_ascii = False).encode('utf8'))
        except KeyError:
            if DEBUG: print msg, params.keys()
            params['request']['protocol'].transport.write(simplejson.dumps(msg, ensure_ascii = False).encode('utf8'))
            params['request']['protocol'].transport.loseConnection()
        """
        msg = "Closing Python Manager - Goodbye."
        try:
            params['request']['write'](msg)
        except KeyError: 
             params['request']['protocol'].transport.write(msg)
             params['request']['protocol'].transport.loseConnection()
        """
        self.server.stop()

    def request_content(self,params):
        """
        generates or looks up and supplies a live content item
        """
        if DEBUG: print "class CommandLibrary, func request_content"
        dc = self.__determineContext__(params)
        if (not dc.dict.has_key('_content_manager')):
            dc.update({'_content_manager':live_content.Live_Content_Manager()})
        content = dc['_content_manager'].get_content(params["content_id"],
                                                     requester=params["request"]["protocol"])
        self._deliver_content(params,params["content_id"],content)

    def live_content_event(self,params):
        """
        responds to a live content event by passing it to the content manager
        """
        if DEBUG: print "class CommandLibrary, func live_content_event"
        dc = self.__determineContext__(params)
        if (not dc.dict.has_key('_content_manager')):
            dc.update({'_content_manager':live_content.Live_Content_Manager()})
        dc['_content_manager'].registerEvent(params)
        
    def _deliver_content(self,params,content_id,content):
        """
        sends live_content items to a consumer - is called by request_content
        """
        if DEBUG: print "class CommandLibrary, func _deliver_content"
        content_json = simplejson.dumps({content_id:content})
        msg = {"receive_live_content":content_json}
       # msg = {"receive_live_content":content_json, "data_context":params['data_context']}
        if DEBUG: print msg    
        try: 
            write_method = params["request"]["write"]
        except KeyError:
            write_method = params["request"]["protocol"].sendMessage
        write_method(simplejson.dumps(msg))



    def _respond_and_close(self,params,msg):
        """
        resonds to and closes (for standard HTTP) the socket communication 
        """
        try:
            params['request']['write']('{"server_console":'+msg+'}')
        except KeyError: 
            params['request']['protocol'].transport.write(msg)
            params['request']['protocol'].transport.loseConnection()

        

class ServerCommand():
    def __init__(self,server, command,*args):
        """
        Constructs a server command object, to be executed in the command queue
        
        These objects are separated from the SocketCommand library to provide
        secure functions which cannot be called from sockets.
        """
        self.server = server
        if DEBUG and command != self.server.server_ping and command != self.server.catch_ping: print "In class ServerCommand, func __init__"
        self.command=command
        self.args=args
        
    def execute(self, Library=None):
        if DEBUG and self.command != self.server.server_ping and self.command != self.server.catch_ping: print "In class ServerCommand, func execute"
        #pdb.set_trace()
        try: 
            self.command(*self.args)
        except Exception as e:
            if DEBUG: print e
            pdb.set_trace()

        
class SocketCommand():
    def __init__(self, params=None, request=None, command_library=None):
        """
        Constructs a SocketCommand object, which should contain one parameter
        in dictionary param with name IDLSocket_ResponseFunction, corresponding
        to a name in the command_library.  If command_library is supplied, verifies
        command's existence and tags property 'functional' true
        """
        self.command = params
        self.params = params
        self.request = request
        #print params
        if not params.has_key('IDLSocket_ResponseFunction'):
            '''
            if params.has_key('fake_shotnumber_started'):
                dc = command_library.__determineContext__(params)       
                if not dc.dict.has_key('_exp_sync'):
                     exp_sync = Experiment_Sync_Group(self.server, dc.name)
                     dc.update({'_exp_sync':exp_sync})
                dc.get('_exp_sync').shotnumber = int(params['fake_shotnumber_started'])
                if DEBUG: print "Fake Shot started:", params['fake_shotnumber_started'], "pxi_time:", params['time'], "time.time():", float(time.time())
                self.command = None
                self.params = None
                self.request = None
                return
            '''
            self.functional=False
            if request != None:
                #if DEBUG: print "Error No command included in request", params.keys()
                msg = {'Not_Command_text_message':'No command included in request.','terminator':'die'}
                if request.has_key("write"):
                    request["write"](simplejson.dumps(msg, ensure_ascii = False).encode('utf8'))
                else:                
                    try:
                        request.protocol.transport.write(simplejson.dumps(msg, ensure_ascii = False).encode('utf8'))
                        request.protocol.transport.loseConnection()
                    except:
                        request['protocol'].transport.write(simplejson.dumps(msg, ensure_ascii = False).encode('utf8'))
                        request['protocol'].transport.loseConnection()
            return
        if command_library == None:
            self.functional=False
            return
        if hasattr(command_library,self.params['IDLSocket_ResponseFunction']):
            self.functional=True
            return
        else:
            msg = {'Not_Command_text_message':'No command included in request.','terminator':'die'}
            if request.has_key("write"):
                request["write"](simplejson.dumps(msg, ensure_ascii = False).encode('utf8'))
            else:                
                request.protocol.transport.write(simplejson.dumps(msg, ensure_ascii = False).encode('utf8'))
                request.protocol.transport.loseConnection()  
        return
        
    def execute(self,command_library):
        """
        Executes this command from command_library's functions
        """
        if DEBUG: print "In class SocketCommand, function execute"
        #print "Params:"
        if self.params == None or self.command == None: return
        if self.params.has_key("databomb"):
            if DEBUG: print "---A databomb's data---"
            pass
            #pdb.set_trace()
        else:
            pass
            #print self.params
        p=self.params
        p.update({'request':self.request})
        
        try:
            ThisResponseFunction = getattr(command_library,
                                           self.params['IDLSocket_ResponseFunction'])
        except AttributeError:
            if DEBUG: print ('Missing Socket_ResponseFunction:',
                   self.params['IDLSocket_ResponseFunction'])
        if DEBUG: print "self.params.keys()", self.params.keys()
        if DEBUG: print "Calling this ResponseFunction:",self.params['IDLSocket_ResponseFunction']
        ThisResponseFunction(p)
        '''
        if self.params['IDLSocket_ResponseFunction'] == 'compile_active_xtsm':
            filenames = []
            for i in range(1):
                name = 'c:\psu_data\profile_stats_%d.txt' % i
                profile.runctx('getattr(command_library, self.params["IDLSocket_ResponseFunction"])(self.params)',globals(),locals(), filename=name)
            stats = pstats.Stats('c:\psu_data\profile_stats_0.txt')
            for i in range(0, 1):
                stats.add('c:\psu_data\profile_stats_%d.txt' % i)
            stats.sort_stats('cumulative')
            stats.print_stats()
            pass
        else:
            ThisResponseFunction(p)
        print "In class SocketCommand, function execute - End."
        '''
        #print "In class SocketCommand, function execute - End."

